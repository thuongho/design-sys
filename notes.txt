Design Sys
- contain pure and presentational components only
- no app specific business logic

Create Inventory
- create inventory of most used components

Interface Audit
- get screenshots of ingredients of interface
- Grab headings, text fields, radio buttons, carousels, accordions, tabs, images, icons, video players, graphs, etc, etc.
- get distinct treatments of a component
-- bevel with right facing caret and another with bevel/caret
- categorize so that you can view various treatments of a component side by side

Benefits of catelog interface
- sound design system
- set up style guide or pattern library

Useful heuristics
- UI pattern used more than 3x => reusable component
- UI component used in 3 or more projects/teams, put in design system

Removed create-react-app src default and added src components

yarn add prop-types styled-components polished

Include styling constants for
- typography
- colors
- spacing
- etc that are reused across projects

Design Tokens
- Single Source of Truth
- values are in one place JSON file
- all the css values are variables

Architeching Tokens
1. Show options first, then decisions next

# Choices

color :
  white : &color-white "#FFFFFF"
  black : &color-black "#262626"
  neutral :
    20 : &color-neutral-20 "#222222"
    90 : &color-neutral-90 "#EEEEEE"
  blue:
    50: &color-blue-50 "#2196F3"
    60: &color-blue-60 "#1E88E5"
  # and many more...

# Decisions

interactive-color :
  default: *color-blue-50
  dark: *color-blue-60

background-color :
  default : *color-white
  light : *color-neutral-90
  dark : *color-neutral-20
  disabled: *color-neutral-90

text-color :
  default : *color-neutral-25
  on-light : *color-neutral-25
  on-dark : *color-white
  light : *color-neutral-55
  disabled : *color-neutral-65
  link :
    default : *color-blue-50
    on-dark : *color-white


2. start with color, font and don't stop there
- big 3: color, typography, and iconography

color :
interactive-color :
background-color :
text-color :
font :
	family :
	size :
	line-height :
border : 
size :
	icon :
space :
	inset :
	stack :
	inline :
	grid :
layout :
	row :
	margin :
	gutter : 
shadow :
	block :
	text :
size :
transition :
timing :
layers :
responsive :
theme :
	product :
	age :
	motif :


3. Vary options across meaningful scales
- similarly t-shirts: xs, s, l, xl, xxxl

space :
  default : 16px
  xxs: 2px
  xs: 4px
  s: 8px
  m: 16px
  l: 32px
  xl: 64px
  inset :
    default : 16px 16px 16px 16px
    xxs : 2px 2px 2px 2px
    xs : 4px 4px 4px 4px
    s : 8px 8px 8px 8px
    m : 16px 16px 16px 16px
    l : 32px 32px 32px 32px
    xl : 64px 64px 64px 64px


Implementing Tokens
- consolidating decisions as a huge stack of predictable, hierarchical variable names in SASS
-- but this is buried in one place limiting it to just that tech
- spread tokens throughout a sys by using JSON

7. Make Token data reusable via JSON

8. Manage & read token data via YAML
- JSON is imperfect as a place to manage data
-- prone to error, lacks support, lacks variables 
- YAML more human readable
- variables and comments
- yamljs
-- transform YAML data to JS object
-- https://www.npmjs.com/package/yamljs

9. Automate documentation with token data


Code formatting and linting for hygiene
prettier

Storybook
- component explorer for developing UI components in isolation
install and run Storybook
npx -p @storybook/cli sb init

Add global style to storybook
create .storybook/preview.js
- create src/shared/globalStyle using styledComponents createGlobalstyle
- use globalStyle decorator to wrap story in preview
-- this will ensure GlobalStyle is rendered no matter which story is selected

Add font to storybook
.storybook/preview-head.html
- link fonts

Addon
Storysource
yarn add --dev @storybook/addon-storysource
- this addon shows the underlying code in addon panel
- add to .storybook/main.js

Knobs
- stress test components
- knobs don't replace story
-- great for exploring edge cases
-- stories are used for showcasing the intended cases


Review with Teams
- collaborate with continuous integration and visual review

Single source of truth or single point of failure
- bugs will have a snowballing effect as design system is a dependency

connected to design system
- web app
- marketing site
- mobile app
- docs site

use netlify.toml to deploy to Netlify

create feature branch
- update the design
- create a PR and it will deploy to Netlify
- open an issue and assign it to teammate with the link
- they can check the PR

UI component Testing

Best Practice
- Articulate supported component states as stories to clarify which combinations of inputs yields a given state. Ruthlessly omit unsupported states to reduce noise.
- Render components consistently to mitigate variability that can be triggered by randomized (Math.random) or relative (Date.now) inputs.
- “The best kind of stories allow you to visualize all of the states your component could experience in the wild” – Tim Hingston, Tech lead at Apollo GraphQL

Visual test appearance
- visual test capture image of UI component in browser environment
- new screenshot compared to previous accepted baseline
- get notified for visual differences

chromatic package
yarn add --dev chromatic

publish storybook
yarn chromatic --project-token=<id>

first test to establish your visual test baselines
npx chromatic --project-token=<project-token>


The project token cannot be used to read story data, it can only be used to create new builds.
If you're running Chromatic via continuous integration, we recommend setting \`CHROMATIC_PROJECT_TOKEN\` environment variable in your CI environment. You can then remove the --project-token from your 'package.json'.


Unit Tests
Note: Watch out for too many unit tests which can make updates cumbersome. We recommend unit testing design systems in moderation.

**** Accessibilty Test
“Accessibility means all people, including those with disabilities, can understand, navigate, and interact with your app... Online [examples include] alternative ways to access content such as using the tab key and a screen reader to traverse a site.”

Disabilities affect 15% of the population according to the World Health Organization. 
Design systems have an outsized impact on accessibility because they contain the building blocks of user interfaces.
Improving accessibility of just one component means every instance of that component across your company benefits.

** Get a headstart on inclusive UI with Storybook’s Accessibility addon, a tool for verifying web accessibility standards (WCAG) in realtime.
yarn add --dev @storybook/addon-a11y

add a11y to .storybook/main.js 

add withA11y decorator to preview.js


Snapshot tests (Jest)
This technique captures the code output of UI components and compares it to previous versions. Testing UI component markup ends up testing implementation details (code), not what the user experiences in the browser.

Diffing code snapshots is unpredictable and prone to false positives. At the component level, code snapshotting doesn’t account for global changes like design tokens, CSS, and 3rd party API updates (web fonts, Stripe forms, Google Maps, etc.). In practice, developers resort to “approving all” or ignoring snapshot tests altogether.


End-to-end tests
Validating user flows are often overkill for this task because the tests are time-consuming to create and brittle to maintain. However, in rare situations, components may benefit from end-to-end tests. For instance, validating complex UIs like datepickers or self-contained payment forms.